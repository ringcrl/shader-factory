<head>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    #canvas {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      position: fixed;
      position: relative;
    }

    .error {
      font-family: Consolas;
      font-size: 1.2em;
      color: black;
      box-sizing: border-box;
      background-color: lightcoral;
      border-radius: 2px;
      border-color: lightblue;
      border-width: thin;
      border-style: solid;
      line-height: 1.4em;
      cursor: pointer;
    }

    .error:hover {
      color: black;
      background-color: brown;
      border-color: blue;
    }

    #message {
      font-family: Consolas;
      font-size: 1.2em;
      color: #ccc;
      background-color: black;
      font-weight: bold;
      z-index: 2;
      position: absolute;
    }

    #dat_gui_container {
      /* position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: 45%;
      z-index: 3; */

      margin: 50px auto;
      display: flex;
      justify-content: center;
    }

    /* Pause Button Style */

    /* Resolution Button Style */

    /* Export Button Style */

    /* Screenshot Button Style */

    /* Reload Button Style */
  </style>
</head>

<body>
  <div id="message"></div>
  <div id="container">
    <!-- Resolution Button -->

    <!-- Export Button -->

    <!-- Pause Element -->

    <!-- Screenshot Element -->

    <!-- Reload Element -->
  </div>
</body>
<script src="<!-- JQuery.js -->"></script>
<script src="<!-- Three.js -->"></script>

<!-- Stats.js -->

<!-- dat.gui -->

<canvas id="canvas"></canvas>

<div id="dat_gui_container"></div>

<!-- Shaders -->

<script id="vertexShader" type="x-shader">
attribute vec2 aVertexPosition;
varying vec2 vTextureCoord;

void main(void) {
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  vTextureCoord = uv;
}

</script>

<script type="text/javascript">
  let vscode = undefined;
  if (typeof acquireVsCodeApi === 'function') {
    vscode = acquireVsCodeApi();
  }
  var compileTimePanel;

  let revealError = function (line, file) {
    if (vscode) {
      vscode.postMessage({
        command: 'showGlslsError',
        line: line,
        file: file
      });
    }
  };

  let currentShader = {};
  // Error Callback

  // Development feature: Output warnings from third-party libraries
  // console.warn = function (message) {
  //     $("#message").append(message + '<br>');
  // };

  let clock = new THREE.Clock();
  let pausedTime = 0.0;
  let deltaTime = 0.0;
  let startingTime = <!-- Start Time -->;
  let time = startingTime;

  let date = new THREE.Vector4();

  let updateDate = function () {
    let today = new Date();
    date.x = today.getFullYear();
    date.y = today.getMonth();
    date.z = today.getDate();
    date.w = today.getHours() * 60 * 60
      + today.getMinutes() * 60
      + today.getSeconds()
      + today.getMilliseconds() * 0.001;
  };
  updateDate();

  let paused = false;
  let pauseButton = document.getElementById('pause-button');
  if (pauseButton) {
    pauseButton.onclick = function () {
      paused = pauseButton.checked;
      if (!paused) {
        // Audio Resume
        pausedTime += clock.getDelta();
      }
      else {
        // Audio Pause
      }
    };
  }

  {
    let screenshotButton = document.getElementById("screenshot");
    if (screenshotButton) {
      screenshotButton.addEventListener('click', saveScreenshot);
    }
  }

  {
    let reloadButton = document.getElementById("reload");
    if (reloadButton) {
      reloadButton.addEventListener('click', reloadWebview);
    }
  }

  window.addEventListener('message', event => {
    const message = event.data; // The JSON data our extension sent
    switch (message.command) {
      case 'pause':
        if (pauseButton) {
          pauseButton.checked = !pauseButton.checked;
        }
        paused = !paused;
        if (!paused) {
          // Audio Resume
          pausedTime += clock.getDelta();
        }
        else {
          // Audio Pause
        }
        break;
      case 'screenshot':
        saveScreenshot();
        break;
    }
  });

  let canvas = document.getElementById('canvas');
  let gl = canvas.getContext('webgl2');
  let isWebGL2 = gl != null;
  if (gl == null) gl = canvas.getContext('webgl');
  let supportsFloatFramebuffer = (gl.getExtension('EXT_color_buffer_float') != null) || (gl.getExtension('WEBGL_color_buffer_float') != null);
  let supportsHalfFloatFramebuffer = (gl.getExtension('EXT_color_buffer_half_float') != null);
  let framebufferType = THREE.UnsignedByteType;
  if (supportsFloatFramebuffer) framebufferType = THREE.FloatType;
  else if (supportsHalfFloatFramebuffer) framebufferType = THREE.HalfFloatType;

  let renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, context: gl, preserveDrawingBuffer: true });
  let resolution = new THREE.Vector3();
  let mouse = new THREE.Vector4(<!-- Start Mouse -->);
  let mouseButton = new THREE.Vector4(0, 0, 0, 0);
  let normalizedMouse = new THREE.Vector2(<!-- Start Normalized Mouse -->);
  let frameCounter = 0;

  // Audio Init
  // Audio Resume

  let buffers = [];
  // Buffers
  let commonIncludes = [];
  // Includes

  // WebGL2 inserts more lines into the shader
  if (isWebGL2) {
    for (let buffer of buffers) {
      buffer.LineOffset += 16;
    }
  }

  // Keyboard Init

  // Uniforms Init
  // Uniforms Update

  let texLoader = new THREE.TextureLoader();
  // Texture Init

  let scene = new THREE.Scene();
  let quad = new THREE.Mesh(
    new THREE.PlaneGeometry(resolution.x, resolution.y),
    null
  );
  scene.add(quad);

  let camera = new THREE.OrthographicCamera(-resolution.x / 2.0, resolution.x / 2.0, resolution.y / 2.0, -resolution.y / 2.0, 1, 1000);
  camera.position.set(0, 0, 10);

  // Run every shader once to check for compile errors
  let compileTimeStart = performance.now();
  let failed = 0;
  for (let include of commonIncludes) {
    currentShader = {
      Name: include.Name,
      File: include.File,
      // add two for version and precision lines
      LineOffset: <!-- Preamble Line Numbers --> + 2
    };
    // bail if there is an error found in the include script
    if (compileFragShader(gl, document.getElementById(include.Name).textContent) == false) {
      throw Error(`Failed to compile ${include.Name}`);
    }
  }

  for (let buffer of buffers) {
    currentShader = {
      Name: buffer.Name,
      File: buffer.File,
      LineOffset: buffer.LineOffset
    };
    quad.material = buffer.Shader;
    renderer.setRenderTarget(buffer.Target);
    renderer.render(scene, camera);
  }
  currentShader = {};
  let compileTimeEnd = performance.now();
  let compileTime = compileTimeEnd - compileTimeStart;
  if (compileTimePanel !== undefined) {
    for (let i = 0; i < 200; i++) {
      compileTimePanel.update(compileTime, 200);
    }
  }

  computeSize();
  render();

  function addLineNumbers(string) {
    let lines = string.split('\\n');
    for (let i = 0; i < lines.length; i++) {
      lines[i] = (i + 1) + ': ' + lines[i];
    }
    return lines.join('\\n');
  }

  function compileFragShader(gl, fsSource) {
    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, fsSource);
    gl.compileShader(fs);
    if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
      const fragmentLog = gl.getShaderInfoLog(fs);
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.COMPILE_STATUS', null, null, null, null, fragmentLog);
      return false;
    }
    return true;
  }

  function render() {
    requestAnimationFrame(render);
    // Pause Whole Render

    // Advance Time
    updateDate();

    // Audio Update

    for (let buffer of buffers) {
      buffer.Shader.uniforms['iTime'].value = time;
      buffer.Shader.uniforms['iResolution'].value = resolution;
      
      
      // buffer.Shader.uniforms['resolution'].value = resolution;
      // buffer.Shader.uniforms['time'].value = time;
      // buffer.Shader.uniforms['iTimeDelta'].value = deltaTime;
      // buffer.Shader.uniforms['iFrame'].value = frameCounter;
      // buffer.Shader.uniforms['mouse'].value = normalizedMouse;
      // buffer.Shader.uniforms['iMouse'].value = mouse;
      // buffer.Shader.uniforms['iMouseButton'].value = mouseButton;

      quad.material = buffer.Shader;
      renderer.setRenderTarget(buffer.Target);
      renderer.render(scene, camera);
    }

    // Uniforms Update

    // Keyboard Update

    for (let buffer of buffers) {
      if (buffer.PingPongTarget) {
        [buffer.PingPongTarget, buffer.Target] = [buffer.Target, buffer.PingPongTarget];
        buffer.Shader.uniforms[`iChannel${buffer.PingPongChannel}`].value = buffer.PingPongTarget.texture;
        for (let dependent of buffer.Dependents) {
          const dependentBuffer = buffers[dependent.Index];
          dependentBuffer.Shader.uniforms[`iChannel${dependent.Channel}`].value = buffer.Target.texture;
        }
      }
    }

    frameCounter++;
  }
  function computeSize() {
    // Forced aspect ratio
    let forcedAspects = [<!-- Forced Aspect -->];
    let forcedAspectRatio = forcedAspects[0] / forcedAspects[1];

    let forceAspectRatio = (width, height) => {


      let aspectRatio = width / height;

      if (forcedAspectRatio <= 0 || !isFinite(forcedAspectRatio)) {
        let resolution = new THREE.Vector3(width, height, 1.0);
        return resolution;
      } else if (aspectRatio < forcedAspectRatio) {
        let resolution = new THREE.Vector3(width, Math.floor(width / forcedAspectRatio), 1);
        return resolution;
      } else {
        let resolution = new THREE.Vector3(Math.floor(height * forcedAspectRatio), height, 1);
        return resolution;
      }
    };

    // Compute forced aspect ratio and align canvas
    const width = window.innerWidth;
    let height = window.innerHeight * 0.4;
    if (forcedAspectRatio <= 9 / 16) {
      height *= 2;
    }
    resolution = forceAspectRatio(width, height);
    
    canvas.style.left = `${(window.innerWidth - resolution.x) / 2}px`;
    canvas.style.top = `40px`;

    for (let buffer of buffers) {
      if (buffer.Target) {
        buffer.Target.setSize(resolution.x, resolution.y);
      }
      if (buffer.PingPongTarget) {
        buffer.PingPongTarget.setSize(resolution.x, resolution.y);
      }
    }
    renderer.setSize(resolution.x, resolution.y, false);

    // Update Camera and Mesh
    quad.geometry = new THREE.PlaneGeometry(resolution.x, resolution.y);
    camera.left = -resolution.x / 2.0;
    camera.right = resolution.x / 2.0;
    camera.top = resolution.y / 2.0;
    camera.bottom = -resolution.y / 2.0;
    camera.updateProjectionMatrix();

    // Reset iFrame on resize for shaders that rely on first-frame setups
    frameCounter = 0;
  }
  function saveScreenshot() {
    let doSaveScreenshot = () => {
      renderer.domElement.toBlob(function (blob) {
        let a = document.createElement('a');
        let url = URL.createObjectURL(blob);
        a.href = url;
        a.download = 'shadertoy.png';
        a.click();
      }, 'image/png', 1.0);
    };

    let forcedScreenshotResolution = [<!-- Forced Screenshot Resolution -->];
    if (forcedScreenshotResolution[0] <= 0 || forcedScreenshotResolution[1] <= 0) {
      renderer.render(scene, camera);
      doSaveScreenshot();
    }
    else {
      renderer.setSize(forcedScreenshotResolution[0], forcedScreenshotResolution[1], false);

      for (let buffer of buffers) {
        buffer.Shader.uniforms['iResolution'].value = new THREE.Vector3(forcedScreenshotResolution[0], forcedScreenshotResolution[1], 1);
        buffer.Shader.uniforms['resolution'].value = new THREE.Vector3(forcedScreenshotResolution[0], forcedScreenshotResolution[1], 1);

        quad.material = buffer.Shader;
        renderer.setRenderTarget(buffer.Target);
        renderer.render(scene, camera);
      }

      doSaveScreenshot();
      renderer.setSize(resolution.x, resolution.y, false);
    }
  }
  function reloadWebview() {
    if (vscode !== undefined) {
      vscode.postMessage({ command: 'reloadWebview' });
    }
  }
  function updateMouse() {
    if (vscode !== undefined) {
      vscode.postMessage({
        command: 'updateMouse',
        mouse: {
          x: mouse.x,
          y: mouse.y,
          z: mouse.z,
          w: mouse.w
        },
        normalizedMouse: {
          x: normalizedMouse.x,
          y: normalizedMouse.y
        }
      });
    }
  }
  let dragging = false;
  function updateNormalizedMouseCoordinates(clientX, clientY) {
    let rect = canvas.getBoundingClientRect();
    let mouseX = clientX - rect.left;
    let mouseY = resolution.y - clientY - rect.top;

    if (mouseButton.x + mouseButton.y != 0) {
      mouse.x = mouseX;
      mouse.y = mouseY;
    }

    normalizedMouse.x = mouseX / resolution.x;
    normalizedMouse.y = mouseY / resolution.y;
  }
  canvas.addEventListener('mousemove', function (evt) {
    updateNormalizedMouseCoordinates(evt.clientX, evt.clientY);
    updateMouse();
  }, false);
  canvas.addEventListener('mousedown', function (evt) {
    if (evt.button == 0)
      mouseButton.x = 1;
    if (evt.button == 2)
      mouseButton.y = 1;

    if (!dragging) {
      updateNormalizedMouseCoordinates(evt.clientX, evt.clientY);
      mouse.z = mouse.x;
      mouse.w = mouse.y;
      dragging = true
    }

    updateMouse();
  }, false);
  canvas.addEventListener('mouseup', function (evt) {
    if (evt.button == 0)
      mouseButton.x = 0;
    if (evt.button == 2)
      mouseButton.y = 0;

    dragging = false;
    mouse.z = -mouse.z;
    mouse.w = -mouse.w;

    updateMouse();
  }, false);
  window.addEventListener('resize', function () {
    computeSize();
  });

  const exportBtn = document.querySelector('#export-glsl');
  if (exportBtn) {
    exportBtn.addEventListener('click', () => {
      const fragmentFrames = document.querySelectorAll('script[type="x-shader/x-fragment"]');
      const totalFrameContent = fragmentFrames[fragmentFrames.length - 1].innerHTML;
      copyToClip(totalFrameContent);
      exportBtn.innerHTML = '已复制到剪切板';
      setTimeout(() => {
        exportBtn.innerHTML = '点击导出';
      }, 2000)
    });
  }


  function copyToClip(content) {
    const input = document.createElement('textarea');
    input.value = content;
    document.body.appendChild(input);
    input.select();
    document.execCommand('Copy');
    document.body.removeChild(input);
  }

</script>
